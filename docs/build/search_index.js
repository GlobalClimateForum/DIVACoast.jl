var documenterSearchIndex = {"docs":
[{"location":"#jdiva","page":"Home","title":"jdiva","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"provided by: Global Climate Forum","category":"page"},{"location":"#GeoUtils","page":"Home","title":"GeoUtils","text":"","category":"section"},{"location":"#Geospatial-analysis","page":"Home","title":"Geospatial analysis","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"tools to run geopspatial analysis","category":"page"},{"location":"","page":"Home","title":"Home","text":"Main.jdiva.nh4\nMain.jdiva.distance\nMain.jdiva.go_direction\nMain.jdiva.bounding_boxes\nMain.jdiva.bbox!\nMain.jdiva.is_rotated","category":"page"},{"location":"#Main.jdiva.nh4","page":"Home","title":"Main.jdiva.nh4","text":"nh4(sga :: SparseGeoArray{DT, IT}, x :: Integer, y :: Integer) :: Array{Tuple{IT,IT}}\nnh4(sga :: SparseGeoArray{DT, IT}, p :: Tuple{Integer,Integer}) :: Array{Tuple{IT,IT}}\n\nCompute the 4-Neighbourhood of the grid cell x,y in the SparseGeoArray sga and return as Array of pairs. Takes into account the boundaries of the SparseGeoArray.\n\nExamples\n\njulia> nh4(sga, 1, 1)\n2-element Vector{Tuple{Int32, Int32}}:\n (2, 1)\n (1, 2)\n\njulia> nh4(sga, 2, 4)\n4-element Vector{Tuple{Int32, Int32}}:\n (1, 4)\n (3, 4)\n (2, 3)\n (2, 5)\n\n\n\n\n\n\n","category":"function"},{"location":"#Main.jdiva.distance","page":"Home","title":"Main.jdiva.distance","text":"distance(lon1 :: R, lat1 :: R, lon2 :: R, lat2 :: R) :: R where {R <: Real}\ndistance(p1 :: SVector{2,R}, p2 :: SVector{2,R}) :: R where {R <: Real}\ndistance(p1 :: AbstractVector{R}, p2 :: AbstractVector{R}) :: R where {R <: Real} \ndistance(p1 :: Tuple{R,R}, p2 :: Tuple{R,R}) where {R <: Real} :: R where {R <: Real}\n\nCompute the distance (in km) between two points given by lon1,lat1 and lon2,lat2 resp. p1 and p2. Uses the Haversine formula.\n\nExamples\n\njulia> ...\n\n\n\n\n\n\n","category":"function"},{"location":"#Main.jdiva.go_direction","page":"Home","title":"Main.jdiva.go_direction","text":"go_direction(lon :: R, lat :: R, distance :: Real, direction :: AbstractDirection) :: Tuple{R,R} where {R <: Real}\n\nCompute the geographical coordinates of the point reached if we go distance km from (lon,lat) in direction. Takes into account circularity, but does not cross poles. direction can be East(), North(), West(), South()\n\nExamples\n\njulia> go_direction(13.2240, 52.3057, 10, East())\n(13.370916039175427, 52.3057)\njulia> go_direction(13.2240, 52.3057, 10000, North())\n(13.224, 90.0)\njulia> go_direction(19.0045,0.0,40075,West())\n(19.004500000000007, 0.0)\n\n\n\n\n\n","category":"function"},{"location":"#Main.jdiva.bounding_boxes","page":"Home","title":"Main.jdiva.bounding_boxes","text":"bounding_boxes(sga :: SparseGeoArray{DT, IT}, lon_east :: Real, lon_west :: Real, lat_south :: Real, lat_north :: Real) where {DT <: Real, IT <: Integer}\n\nCompute the bounding box(es) for the sparse geoarray sga and an area from loneast to lonwest and latsouth and latnorth.\n\nExamples\n\njulia> ...\n\n\n\n\n\n\n","category":"function"},{"location":"#Main.jdiva.bbox!","page":"Home","title":"Main.jdiva.bbox!","text":"Set geotransform of SparseGeoArray by specifying a bounding box. Note that this only can result in a non-rotated or skewed GeoArray.\n\n\n\n\n\n","category":"function"},{"location":"#Main.jdiva.is_rotated","page":"Home","title":"Main.jdiva.is_rotated","text":"Check wether the AffineMap of a GeoArray contains rotations.\n\n\n\n\n\n","category":"function"},{"location":"#Geodata-handling","page":"Home","title":"Geodata handling","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"tools to handle geodata","category":"page"},{"location":"","page":"Home","title":"Home","text":"Main.jdiva.epsg!\nMain.jdiva.proj2wkt \nMain.jdiva.epsg2wkt \nMain.jdiva.str2wkt","category":"page"},{"location":"#Main.jdiva.epsg!","page":"Home","title":"Main.jdiva.epsg!","text":"Set CRS on SparseGeoArray by epsgcode\n\n\n\n\n\n","category":"function"},{"location":"#Main.jdiva.proj2wkt","page":"Home","title":"Main.jdiva.proj2wkt","text":"Get the WKT of an Proj string\n\n\n\n\n\n","category":"function"},{"location":"#Main.jdiva.epsg2wkt","page":"Home","title":"Main.jdiva.epsg2wkt","text":"Get the WKT of an Integer EPSG code\n\n\n\n\n\n","category":"function"},{"location":"#Main.jdiva.str2wkt","page":"Home","title":"Main.jdiva.str2wkt","text":"Parse CRS string into WKT.\n\n\n\n\n\n","category":"function"},{"location":"#SparseGeoArray","page":"Home","title":"SparseGeoArray","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"lightweight data structure to store geodata","category":"page"},{"location":"","page":"Home","title":"Home","text":"Main.jdiva.SparseGeoArray\nBase.getindex\nMain.jdiva.coords\nMain.jdiva.indices ","category":"page"},{"location":"#Main.jdiva.SparseGeoArray","page":"Home","title":"Main.jdiva.SparseGeoArray","text":"\n\n\n\n","category":"type"},{"location":"#Base.getindex","page":"Home","title":"Base.getindex","text":"getindex(sga::SparseGeoArray, i::AbstractRange, j::AbstractRange, k::Union{Colon,AbstractRange,Integer})\n\nIndex a SparseGeoArray with AbstractRanges to get a cropped SparseGeoArray with the correct AffineMap set.\n\nExamples\n\njulia> sga[2:3,2:3]\n2x2x1 Array{Float64, 3} with AffineMap([1.0 0.0; 0.0 1.0], [1.0, 1.0]) and undefined CRS\n\n\n\n\n\n","category":"function"},{"location":"#Main.jdiva.coords","page":"Home","title":"Main.jdiva.coords","text":"coords(sga::SparseGeoArray, p::SVector{2,<:Integer}, strategy::AbstractStrategy=Center())\ncoords(sga::SparseGeoArray, p::Tuple{<:Integer,<:Integer}, strategy::AbstractStrategy=Center())\ncoords(sga::SparseGeoArray, p::CartesianIndex{2}, strategy::AbstractStrategy=Center())\n\nRetrieve coordinates of the cell index by p. See indices for the inverse function.\n\n\n\n\n\n","category":"function"},{"location":"#Main.jdiva.indices","page":"Home","title":"Main.jdiva.indices","text":"indices(sga::SparseGeoArray, p::SVector{2,<:Real})\n\nRetrieve logical indices of the cell represented by coordinates p. See coords for the inverse function.\n\n\n\n\n\n","category":"function"},{"location":"#netCDF","page":"Home","title":"netCDF","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"utitlities to work with netCDF-files","category":"page"},{"location":"","page":"Home","title":"Home","text":"Main.jdiva.load_hsps_nc","category":"page"},{"location":"#Main.jdiva.load_hsps_nc","page":"Home","title":"Main.jdiva.load_hsps_nc","text":"load_hsps_nc(::Type{IT}, ::Type{DT}, filename::String)::Dict{IT,HypsometricProfile{DT}} where {IT<:Integer,DT<:Real}\n\nLoad a netcdf file into hypsometric profiles. IT is the indextype (an integer type which is used to adress a specific profile), DT is the datatype (a floating point type which is used to store the data internally). Hypsometric profiles are not compressed.\n\nExamples\n\njulia> test = load_hsps_nc(Int32, Float32, \"test.nc\")\nDict{Int32, HypsometricProfile{Float32}} with 2716 entries:\n  2108 => HypsometricProfile{Float32}(1.0, Float32[-5.0, -4.9, -4.8, -4.7, -4.6, -4.5, -4.4, -4.3, -4.2, -4.1  …  19.1, 19.2, 19.3, 19.4, 19.5, 19.6, 19.7, 19.8, 19.9, 20.0], Float32[0.0, 0.0, 0.0, 0.0, …\n\n\n\n\n\n","category":"function"}]
}
